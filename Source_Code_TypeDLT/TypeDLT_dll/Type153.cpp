#include <cmath>
#include <fstream>
#include "TRNSYS.h" //TRNSYS acess functions (allow to acess TIME etc.)
#include <sstream> // for string streams
#include <cstdlib> // for atof, abort
#include <iostream>
#include <sys/types.h>
#include <dirent.h>
#include <string>
#include <limits>
//************************************************************************
// Object: TypeDLT
// IISiBat Model: Type153
//
// Author(s):  Ulrich Filippi Oberegger, Giuseppe De Michele
// Purpose:    Enabling daylighting simulations within TRNSYS.
// Copyright:  (c) 2015, Accademia Europea Bolzano (EURAC)
//
//             This program is free software under the BSD 3-Clause License.
//             Read the file LICENSE.txt that comes with TypeDLT for details.
//*************************************************************************
// ***
// *** Model Parameters
// ***

// ***
// *** Model Inputs
// ***
//			Latitude	degrees [-90;90]
//			Longitude	degrees [-180;180]
//			Solar zenith angle	degrees [0;90]
//			Solar azimuth angle	degrees [-180;180]
//			Direct normal illuminance	lux [0;+Inf]
//			Diffuse horizontal illuminance	lux [0;+Inf]
//			Month	any [1;12]
//			Day of the month	day [1;31]
//			Hour of the day	hr [0;24]
//			Zone ID	- [1;+Inf]
//			Control	- [0;+Inf]

// ***
// *** Model Outputs
// ***
//			Maximum illuminance	lux [0;+Inf]
//			Minimum illuminance	lux [0;+Inf]
//			Average illuminance	lux [0;+Inf]
//			Control	- [0;+Inf]

// ***
// *** Model Derivatives
// ***

// (Comments and routine interface generated by TRNSYS Studio)
//************************************************************************

//
extern "C" __declspec(dllexport)
int TYPE153           (
    double &time,  // the simulation time
    double xin[],  // the array containing the component InpUTS
    double xout[], // the array which the component fills with its appropriate OUTPUTS
    double &t,     // the array containing the dependent variables for which the derivatives are evaluated
    double &dtdt,  // the array containing the derivatives of T which are evaluated
    double par[],  // the array containing the PARAMETERS of the component
    int info[],    // the information array described in Section 3.3.3 of the manual
    int icntrl     // the control array described in Section 3.3.4 of the manual
)
{
    //*************************************************************************
    //*** TYPE implementation
    //*** This function will be called by TRNSYS
    //*** - once at the beginning of the simulation for initialization
    //*** - once at the beginning of every timestep for initialization
    //*** - once for each iteration of the TRNSYS solver
    //*** - once at the end of each timestep for cleanup
    //*** - once at the end of the simulation for cleanup
    //*************************************************************************
    //
    //***
    //*** WARNING: explanations in the TRNSYS manual use FORTRAN conventions for
    //***          array indices. Subtract 1 to obtain 0-based C or C++ conventions.
    //*** Example:
    //***          TRNSYS manual: info(6) = number of OUTPUTS
    //***          -> write no = info[5] to obtain number of outputs in C or C++
    //***
    //*** We also spell variables in lower case according to C tradition, while they
    //*** are spelled in uppercase in the TRNSYS manual (according to FORTRAN tradition)
    //***


//-----------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------

    // *** STANDARD TRNSYS DECLARATIONS
    int npar= 0;   // number of parameters we expect
    int nin= 11;   // number of inputs
    int nout=4; // number of outputs
    int nder=0;   // number of derivatives
    int iunit; // UNIT number ('serial number' of the component, from the input file (the 'deck')
    int itype; // TYPE number (component number)
    // read context information from TRNSYS
    // (uncomment lines as required)
    info[5] = nout;  // number of outputs

    iunit = info[0]; // UNIT number
    itype = info[1]; // TYPE number

    //info[2]	; // number of INPUTS specified by the user of the component
    //info[3]	; // number of PARAMETERS specified by the user of the component
    //info[4]	; // number of DERIVATIVES specified by the user of the component
    //info[5]	; // number of OUTPUTS specified by the user of the component

    //info[6]	; // number of iterative calls to the UNIT in the current timestep
    // -2 = initialization
    // -1	= initial call in simulation for this UNIT
    //  0 = first call in timestep for this UNIT.
    //  1	= second call in timestep for this UNIT, etc.

    //info(7)	; // total number of calls to the UNIT in the simulation
    // *** inform TRNSYS about properties of this type
    info[8] = 0; // indicates whether TYPE depends on the passage of time: 0=no
    info[9]	= 0; //	use to allocate storage (see Section 3.5 of the TRNSYS manual): 0 = none
    // info[10]; // indicates number of discrete control variables (see Section 3.3.4 of the TRNSYS manual)
//-----------------------------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------------------------
//    ADD DECLARATIONS AND DEFINITIONS FOR THE USER-VARIABLES HERE

//-----------------------------------------------------------------------------------------------------------------------

//    PARAMETERS

//    INPUTS
    double Latitude;
    double Longitude;
    double Solar_zenith_angle;
    double Solar_azimuth_angle;
    double Direct_normal_illuminance;
    double Diffuse_horizontal_illuminance;
    double Month;
    double Day_of_the_month;
    double Hour_of_the_day;
    double Zone_ID;
    double Control;

//-----------------------------------------------------------------------------------------------------------------------
//       READ IN THE VALUES OF THE PARAMETERS IN SEQUENTIAL ORDER

//-----------------------------------------------------------------------------------------------------------------------
//    RETRIEVE THE CURRENT VALUES OF THE INPUTS TO THIS MODEL FROM THE XIN ARRAY IN SEQUENTIAL ORDER

    Latitude=xin[0];
    Longitude=xin[1];
    Solar_zenith_angle=xin[2];
    Solar_azimuth_angle=xin[3];
    Direct_normal_illuminance=xin[4];
    Diffuse_horizontal_illuminance=xin[5];
    Month=xin[6];
    Day_of_the_month=xin[7];
    Hour_of_the_day=xin[8];
    Zone_ID=xin[9];
    Control=xin[10];
    iunit=info[0];
    itype=info[1];

//-----------------------------------------------------------------------------------------------------------------------
//    SET THE VERSION INFORMATION FOR TRNSYS
    if (info[6]== -2)
    {
        info[11]=16;
        // add additional initialisation code here, if any
        return 1;
    }
//-----------------------------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------------------------
//    DO ALL THE VERY LAST CALL OF THE SIMULATION MANIPULATIONS HERE
    if (info[7]== -1)
    {
        return 1;
    }
//-----------------------------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------------------------
//    PERFORM ANY 'AFTER-ITERATION' MANIPULATIONS THAT ARE REQUIRED HERE
//    e.g. save variables to storage array for the next timestep
    if (info[12]>0)
    {
//	   nitems=0;
//	   stored[0]=... (if NITEMS > 0)
//        setStorageVars(STORED,NITEMS,INFO)
        return 1;
    }
//-----------------------------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------------------------
//    DO ALL THE VERY FIRST CALL OF THE SIMULATION MANIPULATIONS HERE
    if (info[6]== -1) // first call of this component in the simulation
    {
//       SET SOME INFO ARRAY VARIABLES TO TELL THE TRNSYS ENGINE HOW THIS TYPE IS TO WORK
        info[5]=nout;
        info[8]=1;
        info[9]=0;	// STORAGE FOR VERSION 16 HAS BEEN CHANGED

//       SET THE REQUIRED NUMBER OF INPUTS, PARAMETERS AND DERIVATIVES THAT THE USER SHOULD SUPPLY IN THE INPUT FILE
//       IN SOME CASES, THE NUMBER OF VARIABLES MAY DEPEND ON THE VALUE OF PARAMETERS TO THIS MODEL....
        nin=11;
        npar=0;
        nder=0;

//       CALL THE TYPE CHECK SUBROUTINE TO COMPARE WHAT THIS COMPONENT REQUIRES TO WHAT IS SUPPLIED IN
//       THE TRNSYS INPUT FILE
        int dummy=1;
        TYPECK(&dummy,info,&nin,&npar,&nder);

//       SET THE NUMBER OF STORAGE SPOTS NEEDED FOR THIS COMPONENT
//         nitems=0;
//	     setStorageSize(nitems,info)


        std::string Zone_ID_str = "Zone" + (static_cast<std::ostringstream*>( &(std::ostringstream() << Zone_ID) )->str());

//      Create and launch view matrix batch file
//
        std::string vmx_batch_filename = Zone_ID_str+"\\vmx.bat";
        std::ofstream vmx_batch_file(vmx_batch_filename.c_str());
        std::string vd_filename = Zone_ID_str+"\\window\\win.vd"; // file containing window names, normals to windows pointing to the inside and view up vectors; window names have to correspond to *.rad file names
        std::ifstream vd_file(vd_filename.c_str());


        vmx_batch_file << "@REM View Matrix batch file" << std::endl;
        vmx_batch_file << "SET RAYPATH=.;C:\\Trnsys17\\Radiance\\lib;\%RAYPATH\%" << std::endl; // setting of the Path and Raypath for the Radiance version 4.2.a.2
        vmx_batch_file << "SET PATH=.;C:\\Trnsys17\\Radiance\\bin\\;\%PATH\%" << std::endl;
        vmx_batch_file << "c:" << std::endl;
        vmx_batch_file << "cd /d \%~dp0" << std::endl;
        vmx_batch_file << "oconv " << Zone_ID_str << ".rad ";

        int n_windows; // number of windows
        vd_file >> n_windows;

        std::string *window_names = new std::string[n_windows];
        double **viewdir = new double*[n_windows];
        for(int i = 0; i < n_windows; ++i)
            viewdir[i] = new double[6];

        int counter = 0;

        while (vd_file >> window_names[counter] >> viewdir[counter][0] >> viewdir[counter][1] >> viewdir[counter][2] >> viewdir[counter][3] >> viewdir[counter][4] >> viewdir[counter][5])
        {
            vmx_batch_file << "window/" << window_names[counter] << ".rad ";
            counter++;
        }
        vmx_batch_file << "> temp/model_vmx.oct" << std::endl;
        vmx_batch_file << "rcontrib -f klems_int.cal -bn Nkbins -o data/grid_%%s.vmx";

        vd_file.close();

        for (int counter = 0; counter < n_windows; counter++)
        {
            vmx_batch_file << " -b \"kbin(" << viewdir[counter][0];
            for (int counter_dim = 1; counter_dim < 6; counter_dim++)
            {
                vmx_batch_file << "," << viewdir[counter][counter_dim];
            }
            vmx_batch_file << ")\" -m " << window_names[counter];
        }
        vmx_batch_file << " -I+ -ab 12 -ad 50000 -lw 2e-5 temp/model_vmx.oct < data/grid.pts";

        vmx_batch_file.close();

        system(vmx_batch_filename.c_str());


        // Create the sky file needed in order to create the Daylighting matrix
        std::string sky_filename = Zone_ID_str+"\\temp\\sky_white1.rad";
        std::ofstream sky_file(sky_filename.c_str());

        sky_file << "void glow sky_glow" << std::endl;
        sky_file << "0" << std::endl;
        sky_file << "0" << std::endl;
        sky_file << "4 1 1 1 0" << std::endl;
        sky_file << std::endl;
        sky_file << "sky_glow source sky1" << std::endl;
        sky_file << "0" << std::endl;
        sky_file << "0" << std::endl;
        sky_file << "4 0 0 1 360" << std::endl;


        // Create and launch daylighting matrix batch file
        std::string dmx_batch_filename = Zone_ID_str+"\\dmx.bat";
        std::ofstream dmx_batch_file(dmx_batch_filename.c_str());


        dmx_batch_file << "@REM Daylighting Matrix batch file" << std::endl;
        dmx_batch_file << "SET RAYPATH=.;C:\\Trnsys17\\Radiance\\lib;\%RAYPATH\%" << std::endl;
        dmx_batch_file << "SET PATH=.;C:\\Trnsys17\\Radiance\\bin\\;\%PATH\%" << std::endl;
        dmx_batch_file << "c:" << std::endl;
        dmx_batch_file << "cd /d %~dp0" << std::endl;
        dmx_batch_file << "oconv " << Zone_ID_str << ".rad temp/sky_white1.rad > temp/model_dmx.oct" << std::endl;
        for (int i = 0; i < n_windows; i++)
        {
            // NOTE: view direction has to be inverted in order to point to the outside
            dmx_batch_file << "genklemsamp.pl -c 1000 -vd " << -viewdir[i][0] << " " << -viewdir[i][1] << " " << -viewdir[i][2] <<
                           " -vu " << viewdir[i][3] << " " << viewdir[i][4] << " " << viewdir[i][5] << " window/" << window_names[i] <<
                           ".rad | rcontrib -c 1000 -e MF:4 -f reinhart.cal -b rbin -bn Nrbins -o data/" << window_names[i] << ".dmx -m sky_glow -faa temp/model_dmx.oct" << std::endl;
        }
        dmx_batch_file.close();

        system(dmx_batch_filename.c_str());

        delete[] window_names;

        for(int i = 0; i < n_windows; ++i)
        {
            delete[] viewdir[i];
        }
        delete[] viewdir;

        //       RETURN TO THE CALLING PROGRAM
        return 1;
    }

    //-----------------------------------------------------------------------------------------------------------------------
    //    DO ALL OF THE INITIAL TIMESTEP MANIPULATIONS HERE - THERE ARE NO ITERATIONS AT THE INTIAL TIME
    if (time < (getSimulationStartTime() +
                getSimulationTimeStep()/2.0))
    {
        //       SET THE UNIT NUMBER FOR FUTURE CALLS
        iunit=info[0];
        itype=info[1];

        //       CHECK THE PARAMETERS FOR PROBLEMS AND RETURN FROM THE SUBROUTINE IF AN ERROR IS FOUND
        //         if(...) TYPECK(-4,INFO,0,"BAD PARAMETER #",0)

        //       PERFORM ANY REQUIRED CALCULATIONS TO SET THE INITIAL VALUES OF THE OUTPUTS HERE
//		 Maximum illuminance
			xout[0]=0.0;
//		 Minimum illuminance
			xout[1]=0.0;
//		 Average illuminance
			xout[2]=0.0;
//		 Control
			xout[3]=0.0;

        //       PERFORM ANY REQUIRED CALCULATIONS TO SET THE INITIAL STORAGE VARIABLES HERE
        //         nitems=0;
        //	   stored[0]=...

        //       PUT THE STORED ARRAY IN THE GLOBAL STORED ARRAY
        //         setStorageVars(stored,nitems,info)

        //       RETURN TO THE CALLING PROGRAM
        return 1;

    }
    //-----------------------------------------------------------------------------------------------------------------------

    //-----------------------------------------------------------------------------------------------------------------------
    //    *** ITS AN ITERATIVE CALL TO THIS COMPONENT ***
    //-----------------------------------------------------------------------------------------------------------------------


    //-----------------------------------------------------------------------------------------------------------------------
    //    RETRIEVE THE VALUES IN THE STORAGE ARRAY FOR THIS ITERATION
    //      nitems=
    //	    getStorageVars(stored,nitems,info)
    //      stored[0]=
    //-----------------------------------------------------------------------------------------------------------------------
    //-----------------------------------------------------------------------------------------------------------------------
    //    CHECK THE INPUTS FOR PROBLEMS
    //      if(...) TYPECK(-3,INFO,'BAD INPUT #',0,0)
    //	if(IERROR.GT.0) RETURN 1
    //-----------------------------------------------------------------------------------------------------------------------
    //-----------------------------------------------------------------------------------------------------------------------
    //    *** PERFORM ALL THE CALCULATION HERE FOR THIS MODEL. ***
    //-----------------------------------------------------------------------------------------------------------------------

    //		ADD YOUR COMPONENT EQUATIONS HERE; BASICALLY THE EQUATIONS THAT WILL
    //		CALCULATE THE OUTPUTS BASED ON THE PARAMETERS AND THE INPUTS.	REFER TO
    //		CHAPTER 3 OF THE TRNSYS VOLUME 1 MANUAL FOR DETAILED INFORMATION ON
    //		WRITING TRNSYS COMPONENTS.

    //-----------------------------------------------------------------------------------------------------------------------
    // variable in which output of Type is stored
    double avg = 0.0, ill_max = 0.0, ill_min = 0.0;

    //-----------------------------------------------------------------------------------------------------------------------
    // do nothing if illuminances are zero

    bool illumzero = true;
    if (Direct_normal_illuminance > 0.0 || Diffuse_horizontal_illuminance > 0.0)
        illumzero = false;

    //-----------------------------------------------------------------------------------------------------------------------
    // write batch file with Radiance commands

    if (!illumzero)
    {
        std::string Zone_ID_str = "Zone" + (static_cast<std::ostringstream*>( &(std::ostringstream() << Zone_ID) )->str());
        std::string three_phase_method_batch_filename = Zone_ID_str + "\\3pm.bat";
        std::ofstream three_phase_method_batch_file(three_phase_method_batch_filename.c_str());


        three_phase_method_batch_file << "@REM sky generation and Matrix multiplication with dctimestep" << std::endl;
        three_phase_method_batch_file << "SET RAYPATH=.;C:\\Trnsys17\\Radiance\\lib;\%RAYPATH\%" << std::endl;
        three_phase_method_batch_file << "SET PATH=.;C:\\Trnsys17\\Radiance\\bin\\;\%PATH\%" << std::endl;
        three_phase_method_batch_file << "c:" << std::endl;
        three_phase_method_batch_file << "cd /d %~dp0" << std::endl;
        // NOTE: Longitude in TRNSYS has different sign than longitude required by gendaylit
        three_phase_method_batch_file << "gendaylit " << Month << " " << Day_of_the_month << " +" << Hour_of_the_day <<
                                      " -L " << Direct_normal_illuminance << " " << Diffuse_horizontal_illuminance << " -a " << Latitude <<
                                      " -o " << -Longitude << " -i 60 | genskyvec.pl -m 4 -c 1 1 1 > temp/skysun.skv" << std::endl;

        std::string vd_filename = Zone_ID_str + "\\window\\win.vd"; // file containing window names, normals to windows pointing to the inside and view up vectors; window names have to correspond to *.rad file names
        std::ifstream vd_file(vd_filename.c_str());

        int n_windows; // number of windows
        vd_file >> n_windows;

        std::string *window_names = new std::string[n_windows];

        int counter = 0;

        while (vd_file >> window_names[counter])
        {
            vd_file.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            counter++;
        }

        vd_file.close();

        three_phase_method_batch_file << "rlam ";

        // RGB channels
        std::string RGB_ch[3];
        RGB_ch[0] = "$1";
        RGB_ch[1] = "$2";
        RGB_ch[2] = "$3";

        for (int i = 0; i < n_windows; i++)
        {
            std::string bsdf_filename;
            bsdf_filename = static_cast<std::ostringstream*>( &(std::ostringstream() << Control ) )->str() + ".xml";

            three_phase_method_batch_file << "\"!dctimestep data/grid_" << window_names[i] << ".vmx data/bsdf/" << bsdf_filename << " data/" << window_names[i] << ".dmx temp/skysun.skv\" ";
            if (i < n_windows-1)
            {

                for (int j = 0; j < 3; j++)
                {
                    RGB_ch[j] += "+$" + (static_cast<std::ostringstream*>( &(std::ostringstream() << 3*i+4+j) )->str());
                }
            }
        }

        three_phase_method_batch_file << "| rcalc -e \"$1=179*((" << RGB_ch[0] << ")*0.265+(" << RGB_ch[1] << ")*0.670+(" << RGB_ch[2] << ")*0.0065)\" > data/ill_wind.dat";

//    fprintf(three_phase_method_batch_file, "ping 192.0.2.2 -n 2 -w 1000 > nul\n");

        delete[] window_names;

        three_phase_method_batch_file.close();

//-----------------------------------------------------------------------------------------------------------------------
// execute batch file

        system(three_phase_method_batch_filename.c_str());

//-----------------------------------------------------------------------------------------------------------------------
// store radiance results and calculate output of Type

        FILE *illuminances, *radiance_results;

        illuminances = fopen("illuminances.csv", "a");

        std::string radiance_results_filename = Zone_ID_str + "\\data\\ill_wind.dat";

        radiance_results = fopen(radiance_results_filename.c_str(), "r");

        if (illuminances == NULL || radiance_results == NULL)
        {
            abort();
        }

        char result_str[300];
        double result_double;
        int n_avg = 0;

        // NOTE: the last output row of dctimestep is empty and IS THEREFORE NOT STORED in the outputs file in the following loop
        do
        {
            result_double = atof(fgets(result_str, 300, radiance_results));
            if (!feof(radiance_results))
                fprintf(illuminances, "%f\n", result_double);
            ill_max = (result_double > ill_max) ? result_double : ill_max;
            ill_min = (result_double < ill_min) ? result_double : ill_min;
            avg += result_double;
            n_avg++;
        }
        while (!feof(radiance_results));

        avg /= n_avg;

        fclose(radiance_results);
        fclose(illuminances);
    }

//-----------------------------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------
//    SET THE STORAGE ARRAY AT THE END OF THIS ITERATION IF NECESSARY
//      nitmes=
//      stored(1)=
//	    setStorageVars(STORED,NITEMS,INFO)
//-----------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------
//    REPORT ANY PROBLEMS THAT HAVE BEEN FOUND USING CALLS LIKE THIS:
//      MESSAGES(-1,'put your message here','MESSAGE',IUNIT,ITYPE)
//      MESSAGES(-1,'put your message here','WARNING',IUNIT,ITYPE)
//      MESSAGES(-1,'put your message here','SEVERE',IUNIT,ITYPE)
//      MESSAGES(-1,'put your message here','FATAL',IUNIT,ITYPE)
//-----------------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------------
//    SET THE OUTPUTS FROM THIS MODEL IN SEQUENTIAL ORDER AND GET OUT

//	Maximum illuminance
    xout[0]=ill_max;
//  Minimum illuminance
    xout[1]=ill_min;
//  Average illuminance
    xout[2]=avg;
//  Control
    xout[3]=Control;

//-----------------------------------------------------------------------------------------------------------------------
//    EVERYTHING IS DONE - RETURN FROM THIS SUBROUTINE AND MOVE ON
    return 1;
}
//-----------------------------------------------------------------------------------------------------------------------
